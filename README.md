[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/pAqzQF7v)
# Лабораторна робота 4: Кодування Хаффмана

Реалізація алгоритму стиснення даних за методом Хаффмана з використанням бінарного дерева.

## Опис проєкту

Кодування Хаффмана — це жадібний алгоритм для стиснення даних без втрат. Він створює оптимальне префіксне кодування, де
символи з вищою частотою отримують коротші коди. Цей проєкт реалізує повний цикл стиснення та розпакування текстових
файлів.

## Структура проєкту

```
lab04/
├── DataStructures/
│   └── HuffmanNode.cs            # Вузол дерева Хаффмана
├── Implementations/
│   ├── ICompressor.cs            # Інтерфейс компресора
│   └── HuffmanCompressor.cs      # Основна логіка алгоритму Хаффмана
├── Models/
│   ├── CompressionResult.cs      # Модель результатів стиснення
│   └── FileProcessor.cs          # Допоміжний клас для роботи з файлами
├── UI/
│   └── Output.cs                 # Консольне відображення результатів
├── TestFiles/
│   ├── sample1.txt               # Тестовий файл з алгоритмічним текстом
│   ├── sample2.txt               # Тестовий файл з повторюваними символами
│   ├── sample3.txt               # Тестовий файл з англійським текстом
│   └── sample4.txt               # Тестовий файл з рівномірним розподілом
├── Program.cs                    # Основний файл програми (автозапуск тестів)
```

## Завдання для реалізації

### Завдання 1: Побудова таблиці частот

**Файл:** `Implementations/HuffmanCompressor.cs`, рядок 45

**Сигнатура методу:**

```csharp
private Dictionary<char, int> BuildFrequencyTable(string text)
```

**Мета:** Підрахувати кількість входжень кожного символу в тексті.

**Вимоги:**

- Пройтися по всіх символах вхідного тексту
- Зберегти кількість появ кожного символу в `Dictionary<char, int>`
- Ключ — це символ, значення — його кількість у тексті

---

### Завдання 2: Побудова дерева Хаффмана

**Файл:** `Implementations/HuffmanCompressor.cs`, рядок 50

**Сигнатура методу:**

```csharp
private HuffmanNode BuildHuffmanTree(Dictionary<char, int> frequencies)
```

**Мета:** Побудувати оптимальне дерево кодування на основі частот символів.

**Вимоги:**

- Реалізувати алгоритм Хаффмана
- Подумайте над коллекцією, щоб мінімізуати час який витрачається упорядкування елементів

---

### Завдання 3: Генерація кодів Хаффмана

**Файл:** `Implementations/HuffmanCompressor.cs`, рядок 55

**Сигнатура методу:**

```csharp
private void GenerateCodes(HuffmanNode? node, string code, Dictionary<char, string> codes)
```

**Мета:** Згенерувати бінарні коди для кожного символу на основі побудованого дерева.

**Вимоги:**

- Використати рекурсивний обхід дерева щоб збудувати коди для символів з  `'0'` та `'1'`

---

### Завдання 4: Декодування тексту

**Файл:** `Implementations/HuffmanCompressor.cs`, рядок 40

**Сигнатура методу:**

```csharp
public string Decompress(string compressedText)
```

**Мета:** Декодувати стиснений текст назад у оригінальний текст.

**Вимоги:**

- Використати побудоване дерево Хаффмана (`_root`) і його обхід щоб декодувати вхідний закодований текст з `'0'` та
  `'1'`

## Додаткова інформація

### Алгоритм Хаффмана

Кодування Хаффмана створює оптимальне префіксне кодування:

- Жоден код не є префіксом іншого коду
- Символи з вищою частотою отримують коротші коди
- Гарантує мінімальну середню довжину коду
